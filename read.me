გამოყენებული
  API – https://unsplash.com/documentation
   (აქ საჭიროა ჯერ დარეგისტრირდე,გაეცნო დოკუმენტაციას. 
    ლინკი შეგიძლია location–ში მოძებნო მმისამართი, რომელსაც გამოიყენებ fetchში. ეს გვიგვზავნის json ფორმატს.!!!! აუცილებლად გადაიყვანე response.json().  
     შემდეგ შექმნა აპპ, რათა მოგენიჭოს უნიკსლური ID და key.
     Authorization გრაფაში არის ნიმუში, როგორ შეგიძლია გამოიყენო API.  
     https://api.unsplash.com/photos/?client_id=YOUR_ACCESS_KEY

     
     აქ მხოლოდ შეცვლი YOUR_ACCESS_KEY –ს იმ კოდით, რასაც მოგანიჭებს შენი შექმნილი app.  
PARAMETRS - შესაძლებელია სხვადასხვა პარამეტრის მიხედვით გაფილტვრა. 
ვიყენებთ count -ს. რომლის მიხედვითაც ვაკონტროლებთ 
ფოტოების რაოდენობას. count იწერება key–ს შემდეგ. 
&count=30 მაგალითად. 

   )

svg maker - https://loading.io/


გავლილი თემები 
~ html
centering elements on the page
responsive layout
~css
~dev tools -  network tab - fetch - review. 
~js
1 fetch-ing data from Api
2 display data
getElements
createElements
setatribute
3 infinite Scroll
scroll event
window object
––––––––––––––––––––––––––––––––––––––––––––––––––––––
window.innerHeight = ეკრანზე ხილული ნაწილის სიმაღლე

window.scrollY = რამდენით ჩამოსქროლილია გვერდი

window.innerHeight + window.scrollY ნიშნავს —
მომხმარებლის ხედვის ქვედა წერტილი გვერდზე (viewport-ის ბოლოს პოზიცია). ანუ სიმაღლე – საიდან დაიწყო და კიდევ რამდენი ჩამოსქროლა – ყველაფერი ერთად რამდენი პიქსელია. 

მოხვდა თუ არა მომხმარებელი გვერდის ბოლოში. – window.innerHeight + window.scrollY >= document.body.offsetHeight

მომხმარებელი ახლოსაა გვერდის ბოლოსთან, დაახლოებით 1000 პიქსელით ადრე.
window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000
––––––––––––––––––––––––––––––––––––––––––––––––––––––
4  შემდგგი ეტაპი   : 
სქროლი მხოლოდ უნდა წყვეტდეს → „მივედით თუ არა ქვემოთ?“

ფოტოების წამოღება მხოლოდ fetch-ზე უნდა იყოს პასუხისმგებელი

რენდერი არ უნდა იყოს დამოკიდებული scroll-ზე. 

---------------------------------------------------------------------
loading :
Infinite scroll ყოველთვის იყენებს ერთ იდეას:„თუ უკვე ვტვირთავ, მეორედ აღარ დავტვირთო, 
ამიტომ გჭირდება:

boolean state
ლოგიკა:

ქვემოთ ჩახვედი → თუ არ იტვირთება → დაიწყე fetch

fetch დაიწყო → მონიშნე „იტვირთება“

fetch დასრულდა → მოხსენი მონიშვნა,
------------------------------------
scroll- სიგნალი!!!  სქროლი არ უნდა აკონტროლებდეს რენდერს.
სიგნალი ამბობს: „ახლოს ხარ ბოლოსთან“,
გადაწყვეტილებას იღებს state (loading / canLoadMore)
---------------------------------------------------------
მონაცემები გროვდება, არ იცვლება
ახალი მონაცემები ემატება ძველს, არ ცვლის

ამიტომ:

ფოტოები უნდა ინახებოდეს ერთ საერთო სიაში

ყოველი fetch → ამ სიას ემატება ახალი ელემენტები

რენდერი იყენებს მთლიან სიას

-------------------------------------
6️⃣ Infinite scroll = ციკლი

სწორი infinite scroll ასე მუშაობს:

გვერდი იტვირთება → პირველი მონაცემები

მომხმარებელი სქროლავს

ქვემოთ მიუახლოვდა → trigger

იტვირთება ახალი მონაცემები

მონაცემები ემატება სიას

ციკლი თავიდან იწყება
––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
🚀 Infinite Scroll პროექტის გზამკვლევი1. მოსამზადებელი ეტაპი (API & Setup)პირველი ნაბიჯი არის მონაცემების წყაროს გამართვა.API შერჩევა: ვიყენებთ Unsplash-ს, რადგან ის გვაძლევს რეალურ, მაღალი ხარისხის ფოტოებს.ავტორიზაცია: სტუდენტმა უნდა გაიგოს, რომ API Key არის მისი "პასპორტი".რჩევა: აუხსენი, რომ client_id პარამეტრი URL-ში არის აუცილებელი.პარამეტრები: count პარამეტრი გვეხმარება ოპტიმიზაციაში (არ გვინდა ერთბაშად 100 ფოტოს წამოღება, 10-30 საკმარისია).2. არქიტექტურა (პასუხისმგებლობების დაყოფა)ეს არის ის, რაც შენს ჩანაწერში ძალიან მომეწონა. კოდი უნდა დაიყოს ფუნქციებად:getPhotos(): პასუხისმგებელია მხოლოდ API-სთან "ლაპარაკზე" (Fetch).displayPhotos(): პასუხისმგებელია მხოლოდ HTML-ის აწყობაზე (DOM Manipulation).Scroll Logic: პასუხისმგებელია მხოლოდ მომენტის დაჭერაზე.3. მთავარი გამოწვევა: "სქროლის მათემატიკა"სტუდენტებისთვის ეს ყველაზე რთული ნაწილია. გამოვიყენოთ ვიზუალური ლოგიკა:window.innerHeight: ის, რასაც ახლა ხედავს თვალი (ეკრანის სიმაღლე).window.scrollY: ის, რაც უკვე "ზემოთ აცურდა" (ჩამოსქროლილი მანძილი).document.body.offsetHeight: მთლიანი საიტის სიმაღლე (თავიდან ბოლომდე).ფორმულა:თუ ხედვის სიმაღლე + ჩამოსქროლილი მანძილი >= მთლიან სიმაღლეს - 1000px, ესე იგი მომხმარებელი ბოლოს უახლოვდება და უნდა ჩავტვირთოთ ახალი ფოტოები.4. ოპტიმიზაცია (მიდლური მიდგომა)აქ სტუდენტებს ვასწავლით, როგორ არ "გატეხონ" ბრაუზერი:isLoading Flag: შემოგვაქვს "ჩამკეტი" ცვლადი. სანამ ერთი მოთხოვნა არ მორჩება, მეორეს არ ვუშვებთ.Loader: მომხმარებლის გამოცდილებისთვის (UX) აუცილებელია ვიზუალური დასტური, რომ ჩატვირთვა მიმდინარეობს.Try/Catch/Finally: შეცდომების მართვა. finally ბლოკი არის გარანტია, რომ isLoading ისევ false გახდება, რაიც არ უნდა მოხდეს.💡 მოკლე "Cheat Sheet" სტუდენტებისთვის:ნაბიჯიმოქმედებარატომ ვაკეთებთ?1. Fetchawait fetch(url)მონაცემების მისაღებად.2. JSON.json()ტექსტური პასუხის JS ობიექტად გადასაქცევად.3. LoopforEach()თითოეული ფოტოსთვის ცალკე ელემენტის შესაქმნელად.4. Appendcontainer.append(el)ეკრანზე გამოსაჩენად.5. FlagisLoading = trueრომ API-ზე "სპამი" არ მოხდეს.

––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
📘 გზამკვლევი: Infinite Scroll-ის აგება ნულიდან1️⃣ API-სთან მუშაობის საფუძვლებისანამ კოდს დავწერთ, უნდა მოვამზადოთ "საწვავი" ჩვენი საიტისთვის.რეგისტრაცია: Unsplash დოკუმენტაცია (ყურადღება მიაქციეთ Access Key-ს).URL-ის კონსტრუქტორი: ისწავლეთ პარამეტრების გამოყენება.client_id: თქვენი უნიკალური გასაღები.count: რამდენი ფოტო გსურთ ერთ ჯერზე? (ოპტიმალურია 10-30).JSON-ის გარდაქმნა: fetch გვიბრუნებს "ნედლ" პასუხს, რომელიც აუცილებლად უნდა გარდავქმნათ: response.json().2️⃣ ვიზუალური მათემატიკა (Scroll Logic)როგორ ხვდება ბრაუზერი, რომ მომხმარებელი ბოლოშია? სამი ცვლადის ჯამით:window.innerHeight: ეკრანის ხილული ნაწილი.window.scrollY: მანძილი, რომელიც უკვე ჩამოვსქროლეთ.document.body.offsetHeight: მთლიანი საიტის სიმაღლე.ფორმულა: innerHeight + scrollY >= offsetHeight - 1000(ჩვენ ვიყენებთ -1000px-ს, რათა ფოტოები წინასწარ წამოვიდეს და მომხმარებელს ლოდინი არ მოუხდეს).3️⃣ State-ის მართვა (The Loading Flag)ეს არის პროექტის "ტვინი". სქროლი წამში ათეულობით სიგნალს გზავნის, ჩვენ კი მხოლოდ ერთი მოთხოვნა გვჭირდება.პრობლემა: "Spamming" (ასობით ფეჩი ერთდროულად).გადაწყვეტა: isLoading (boolean).ლოგიკა:ჩახვედი ბოლოში? -> იკითხე: isLoading არის false?თუ კი -> გახადე true -> დაიწყე fetch.დასრულდა fetch? -> გახადე false.4️⃣ მონაცემთა ნაკადი (Data Flow)მონაცემები არ უნდა "გადაიწეროს", ისინი უნდა "დაგროვდეს".მთავარი სია: შექმენი მასივი, სადაც ყველა ფოტო მოგროვდება.Append, არა Overwrite: HTML-ში ახალი ფოტოები უნდა მიემატოს (append) არსებულს და არ წაშალოს ძველი.რენდერი: ფეჩის შემდეგ გამოიძახე ფუნქცია, რომელიც მხოლოდ ახლად წამოსულ მონაცემებს დახატავს.5️⃣ კოდის სტრუქტურა (Best Practices)სტუდენტებმა უნდა ისწავლონ ფუნქციების დამოუკიდებლობა:ფუნქციაპასუხისმგებლობაgetPhotos()მხოლოდ API-დან მონაცემების ამოღება და შეცდომების მართვა.displayPhotos()მხოლოდ DOM-ის შექმნა (createElement, setAttribute).Scroll Eventმხოლოდ იმის შემოწმება, დროა თუ არა ახალი ფოტოებისთვის.6️⃣ სრული ციკლი (Infinite Loop)აუხსენი სტუდენტებს, რომ ეს არის წრე:გვერდის ჩატვირთვა (პირველი 10 ფოტო).მომხმარებელი სქროლავს.trigger (ბოლოში მიახლოება).fetch (ახალი 10 ფოტო).append (ფოტოების დამატება).isLoading = false (მზადყოფნა შემდეგი სქროლისთვის).

––––––––––––––––––––––––––––––––––––––––––––––––––––––
📚 თეორიული მასალა მოსამზადებლად
1. ასინქრონული JavaScript (Promises & Async/Await)
ეს არის პროექტის ხერხემალი. სტუდენტმა უნდა იცოდეს:

რა არის Promise და რატომ გვჭირდება ის API-სთან მუშაობისას.

try...catch ბლოკი – როგორ დავიჭიროთ შეცდომები, თუ ინტერნეტი გაწყდა.

fetch() ფუნქცია და მისი ორი ეტაპი: ჯერ პასუხის მიღება (response) და შემდეგ მისი გარდაქმნა (.json()).

2. მასივებთან მუშაობა (Array Methods)
ჩვენ API-დან ვიღებთ მონაცემთა მასივს.

forEach() – როგორ გადავუაროთ მასივს და თითოეული ელემენტისთვის შევასრულოთ მოქმედება (მაგალითად, შევქმნათ სურათი).

map() (სასურველია) – მასივის ტრანსფორმაციისთვის.

3. DOM Manipulation (ელემენტების მართვა)
კოდმა უნდა შეძლოს HTML-ის დინამიურად შეცვლა.

document.createElement() – ახალი <img> და <a> თეგების შექმნა.

setAttribute() – სურათისთვის src და alt ატრიბუტების მინიჭება.

appendChild() ან append() – შექმნილი ელემენტის ჩასმა კონტეინერში.

4. ობიექტის ობიექტი (Destructuring & Accessing Data)
Unsplash-ის პასუხი არის რთული ობიექტი.

სტუდენტმა უნდა იცოდეს, როგორ ამოიღოს მონაცემი ობიექტიდან, მაგალითად: photo.urls.regular ან photo.links.html.

5. JavaScript Events (მოვლენები)
addEventListener('scroll', ...) – სქროლის დაჭერა.

მნიშვნელოვანი: load event. სტუდენტმა უნდა იცოდეს, რომ სურათის შექმნა არ ნიშნავს მის ჩატვირთვას. load გვეუბნება, როდის დასრულდა ფოტოს ვიზუალური გამოჩენა.

6. პირობითი ოპერატორები (Ternary Operator)
ჩვენ ვიყენებთ მოკლე ჩაწერის ფორმას URL-ის და count-ისთვის.

მაგალითად: let result = condition ? valueIfTrue : valueIfFalse;

7. CSS პოზიციონირება (Flexbox/Grid)
იმისთვის, რომ სურათები ლამაზად განლაგდეს და ლოდერი (loader) ეკრანის ცენტრში იყოს, სტუდენტმა უნდა იცოდეს ელემენტების ცენტრირება.

💡 რჩევა სტუდენტს:
სთხოვე სტუდენტს, რომ გახსნას Unsplash-ის API დოკუმენტაცია და ნახოს "Sample Response" (როგორ გამოიყურება მათგან გამოგზავნილი მონაცემები). ეს დაეხმარება მას იმის გააზრებაში, თუ რატომ ვწერთ element.urls.small.
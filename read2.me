ეტაპი 1: საფუძველი (The Skeleton)
პირველ რიგში, გვჭირდება ფუნქცია, რომელიც უბრალოდ  API-დან მონაცემებს კონსოლში გამოიტანს.

შენი დავალება: დაწერე async function getPhotos(), რომელიც გამოიყენებს fetch-ს და დალოგავს (console.log) Unsplash-იდან წამოღებულ მასივს.

მინიშნება: არ დაგავიწყდეს await ორჯერ: ერთხელ fetch-ისთვის და მეორედ .json()-ისთვის.

ეტაპი 2: ვიზუალიზაცია (The Display)
ახლა, როცა მონაცემები კონსოლში გვაქვს, ისინი ეკრანზე უნდა გამოვიტანოთ.

შენი გამოწვევა: შექმენი ფუნქცია displayPhotos(photos), რომელიც ამ მასივს "გადაურბენს" (forEach) და თითოეული ფოტოსთვის შექმნის <img> თეგს.

ლოგიკური ნაბიჯი: როგორ "ჩასვამ" ამ სურათს შენს HTML კონტეინერში? (გამოიყენე createElement და appendChild).

მინიშნება: Unsplash-ის ობიექტში სურათის ლინკი ინახება urls.regular-ში.

ეტაპი 3: სქროლის "სიგნალი" (The Trigger)
მონაცემები ეკრანზეა. ახლა უნდა მივხვდეთ, როდის დავუძახოთ getPhotos-ს ხელახლა.

დაფიქრდი: რომელი სამი მნიშვნელობა გვჭირდება იმისთვის, რომ გავიგოთ, მომხმარებელი გვერდის ბოლოშია თუ არა?

ეკრანის სიმაღლე.

რამდენით ჩამოვსქროლეთ.

მთლიანი დოკუმენტის სიმაღლე.

დავალება: დაწერე window.addEventListener('scroll', ...) და შიგნით უბრალოდ დაპრინტე "ბოლოში ვარ!", როცა მათემატიკური პირობა შესრულდება. ჯერ არ გამოიძახო ფეჩი, უბრალოდ პირობა გამართე.

ეტაპი 4: პირველი გაუმჯობესება - "ჩამკეტი" (The Loading Guard)
აქ შევეჩეხებით პრობლემას: სქროლის დროს getPhotos წამში 20-ჯერ გამოიძახება.

კითხვა შენ: როგორ შეგვიძლია გამოვიყენოთ ერთი მარტივი boolean ცვლადი (მაგ: isReady), რომ სანამ ერთი მოთხოვნა არ მორჩება, მეორე არ გაეშვას? სად უნდა გახდეს ის false და სად true?

ეტაპი 5: "ჭკვიანი" ჩატვირთვა (Image Loading Control)
ეს ის ეტაპია, სადაც API-დან ტექსტის მოსვლა არ ნიშნავს, რომ სურათი უკვე ეკრანზეა.

დავალება შენთვის: როგორ აიძულებ კოდს, რომ "დაიცადოს" მანამ, სანამ ყველა სურათი (მაგალითად 30-ივე) ფიზიკურად არ ჩაიტვირთება ბრაუზერში?

მინიშნება: გამოიყენე img.addEventListener('load', ...) და ცვლადი, რომელიც დათვლის ჩატვირთულ სურათებს.

5. სურათების "ჭკვიანი" ჩატვირთვა (Image Loading Logic)
მარტო მონაცემების (JSON) წამოღება არ ნიშნავს, რომ საიტი მზადაა. ფიზიკური სურათების ჩატვირთვას დრო სჭირდება.

იდეა: „არ ჩავთვალო ჩატვირთვა დასრულებულად, სანამ ყველა <img> თეგი არ შეივსება ფოტოთი.“

Counter (მთვლელი): გვჭირდება imagesLoaded და totalImages.

Event Listener: თითოეულ სურათზე ვამაგრებთ load ივენთს.

ლოგიკა:

სურათი ჩაიტვირთა → imagesLoaded++.

თუ imagesLoaded === totalImages → მხოლოდ მაშინ გახდეს isloading = false.

ეს იცავს საიტს "სურათების დაჯახებისგან" და ზედმეტი მოთხოვნებისგან.

6. პირველადი ჩატვირთვის ოპტიმიზაცია (Initial Load vs Scroll Load)
საიტის სწრაფი გახსნა კრიტიკულია.

იდეა: „თავიდან წამოვიღოთ ცოტა, რომ მომხმარებელმა დიდხანს არ ელოდოს, ხოლო სქროლისას — ბევრი.“

Boolean Flag: initialLoad = true.

Ternary Operator: let fetchCount = initialLoad ? 5 : 30.

ლოგიკა:

პირველი გამოძახება → მოაქვს 5 ფოტო.

წარმატებული ჩატვირთვის შემდეგ → initialLoad = false.

შემდეგი სქროლი → მოაქვს 30 ფოტო.

7. ძებნის ფუნქციონალი (Search Integration)
პროექტის გადაყვანა "რენდომ" რეჟიმიდან "მიზნობრივ" ძებნაზე.

იდეა: „გამოვიყენოთ სხვადასხვა Endpoint იმის მიხედვით, ეძებს თუ არა მომხმარებელი რამეს.“

Endpoint-ების განსხვავება:

Random: /photos/random → პასუხი არის პირდაპირ მასივი [].

Search: /search/photos → პასუხი არის ობიექტი { results: [] }.

URL-ის დინამიური აწყობა: ფუნქცია getUnsplashUrl(count, query) რომელიც თავად წყვეტს, რომელი ლინკი დააბრუნოს.

ეკრანის გასუფთავება: ახალი ძებნისას აუცილებელია container.innerHTML = '', რათა ძველი და ახალი ფოტოები არ აირიოს.

8. კოდის სისუფთავე და რეფაქტორინგი (Clean Code)
კოდი უნდა იყოს წაკითხვადი და მოქნილი.

Separation of Concerns (პასუხისმგებლობის გაყოფა):

getPhotos — მხოლოდ API-სთან ურთიერთობა.

displayPhotos — მხოლოდ ეკრანზე დახატვა.

getUnsplashUrl — მხოლოდ ლინკის კონსტრუირება.

Error Handling: ყოველთვის გამოიყენე try...catch, რომ ინტერნეტის გათიშვის შემთხვევაში საიტი არ "გატყდეს" და კონსოლში გასაგები შეცდომა დაიწეროს.

💡 შეჯამება სტუდენტისთვის:
Infinite Scroll არ არის მხოლოდ "სქროლი". ეს არის სინქრონიზაცია სამ რამეს შორის:

ბრაუზერის სქროლის პოზიცია.

API-ს მოთხოვნის სტატუსი (isloading).

DOM-ში ელემენტების ფიზიკური ჩატვირთვა (load event).

ამ ჩანაწერებით შენს სტუდენტს ექნება სრული სურათი, თუ როგორ აიგო ეს სისტემა ნაბიჯ-ნაბიჯ.

ხომ არ გინდა, რომელიმე კონკრეტულ ფუნქციაზე (მაგალითად, URL-ის ამწყობზე) უფრო დეტალური კომენტარებიც დავამატოთ?







